"""
System Integration - Direct network control without NetworkManager
Extracted from Rust implementation with enhancements
"""

import subprocess
import asyncio
from pathlib import Path
from typing import Optional

class NetworkControl:
    """Direct network interface control"""
    
    @staticmethod
    async def configure_dhcp(interface: str) -> bool:
        """Configure interface for DHCP"""
        try:
            # Stop any existing DHCP clients
            await NetworkControl._stop_dhcp_clients(interface)
            
            # Start dhcpcd or dhclient
            result = await asyncio.create_subprocess_exec(
                'sudo', 'dhcpcd', interface,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            return result.returncode == 0
            
        except Exception as e:
            print(f"DHCP configuration failed: {e}")
            return False
    
    @staticmethod
    async def configure_static_ip(interface: str, ip: str, gateway: str, dns: list) -> bool:
        """Configure interface with static IP"""
        try:
            # Stop DHCP clients
            await NetworkControl._stop_dhcp_clients(interface)
            
            # Set IP address
            result = await asyncio.create_subprocess_exec(
                'sudo', 'ip', 'addr', 'add', f"{ip}/24", 'dev', interface,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()
            
            if result.returncode != 0:
                return False
            
            # Set gateway
            if gateway:
                result = await asyncio.create_subprocess_exec(
                    'sudo', 'ip', 'route', 'add', 'default', 'via', gateway,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await result.communicate()
            
            # Set DNS
            if dns:
                await NetworkControl._update_resolv_conf(dns)
            
            return True
            
        except Exception as e:
            print(f"Static IP configuration failed: {e}")
            return False
    
    @staticmethod
    async def bring_interface_up(interface: str) -> bool:
        """Bring network interface up"""
        try:
            result = await asyncio.create_subprocess_exec(
                'sudo', 'ip', 'link', 'set', interface, 'up',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            return result.returncode == 0
            
        except Exception as e:
            print(f"Failed to bring up {interface}: {e}")
            return False
    
    @staticmethod
    async def bring_interface_down(interface: str) -> bool:
        """Bring network interface down"""
        try:
            result = await asyncio.create_subprocess_exec(
                'sudo', 'ip', 'link', 'set', interface, 'down',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            return result.returncode == 0
            
        except Exception as e:
            print(f"Failed to bring down {interface}: {e}")
            return False
    
    @staticmethod
    async def _stop_dhcp_clients(interface: str):
        """Stop running DHCP clients for interface"""
        # Kill dhcpcd
        try:
            await asyncio.create_subprocess_exec(
                'sudo', 'pkill', '-f', f'dhcpcd.*{interface}',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
        except:
            pass
        
        # Kill dhclient
        try:
            await asyncio.create_subprocess_exec(
                'sudo', 'pkill', '-f', f'dhclient.*{interface}',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
        except:
            pass
    
    @staticmethod
    async def _update_resolv_conf(dns_servers: list):
        """Update /etc/resolv.conf with DNS servers"""
        try:
            resolv_content = "# Generated by ALOPEX\n"
            for dns in dns_servers:
                resolv_content += f"nameserver {dns}\n"
            
            # Write to temporary file first
            temp_file = "/tmp/alopex_resolv.conf"
            with open(temp_file, 'w') as f:
                f.write(resolv_content)
            
            # Move to system location
            await asyncio.create_subprocess_exec(
                'sudo', 'mv', temp_file, '/etc/resolv.conf',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
        except Exception as e:
            print(f"Failed to update DNS: {e}")

class BluetoothControl:
    """Bluetooth device management without BlueZ complexity"""
    
    @staticmethod
    async def scan_devices() -> list:
        """Scan for Bluetooth devices"""
        try:
            result = await asyncio.create_subprocess_exec(
                'bluetoothctl', '--timeout', '10', 'scan', 'on',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            # Parse bluetoothctl output
            devices = []
            for line in stdout.decode().split('\n'):
                if 'Device' in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        mac = parts[1]
                        name = ' '.join(parts[2:])
                        devices.append({'mac': mac, 'name': name})
            
            return devices
            
        except Exception as e:
            print(f"Bluetooth scan failed: {e}")
            return []
    
    @staticmethod
    async def pair_device(mac_address: str) -> bool:
        """Pair with Bluetooth device"""
        try:
            result = await asyncio.create_subprocess_exec(
                'bluetoothctl', 'pair', mac_address,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            return result.returncode == 0
            
        except Exception as e:
            print(f"Bluetooth pairing failed: {e}")
            return False
    
    @staticmethod
    async def connect_device(mac_address: str) -> bool:
        """Connect to paired Bluetooth device"""
        try:
            result = await asyncio.create_subprocess_exec(
                'bluetoothctl', 'connect', mac_address,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            return result.returncode == 0
            
        except Exception as e:
            print(f"Bluetooth connection failed: {e}")
            return False
    
    @staticmethod
    def get_paired_devices() -> list:
        """Get list of paired Bluetooth devices"""
        try:
            result = subprocess.run(
                ['bluetoothctl', 'paired-devices'],
                capture_output=True, text=True
            )
            
            devices = []
            for line in result.stdout.split('\n'):
                if 'Device' in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        mac = parts[1]
                        name = ' '.join(parts[2:])
                        devices.append({'mac': mac, 'name': name})
            
            return devices
            
        except Exception as e:
            print(f"Failed to get paired devices: {e}")
            return []